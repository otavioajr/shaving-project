name: 'ðŸ”€ Gemini Triage'

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write

jobs:
  triage:
    # SÃ³ roda quando alguÃ©m comentar "/triage"
    if: contains(github.event.comment.body, '/triage')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Get repository labels
        id: labels
        uses: actions/github-script@v8
        with:
          script: |
            const labels = await github.paginate(github.rest.issues.listLabelsForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            if (!labels || labels.length === 0) {
              core.setFailed('There are no issue labels in this repository.');
              return;
            }
            const names = labels.map(l => l.name).sort();
            core.setOutput('available', names.join(','));
            core.info(`Found ${names.length} labels: ${names.join(', ')}`);

      - name: Run Gemini triage
        id: gemini
        uses: google-github-actions/run-gemini-cli@v0
        env:
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          AVAILABLE_LABELS: ${{ steps.labels.outputs.available }}
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          gemini_debug: ${{ runner.debug }}
          prompt: |-
            You are an issue triage assistant for a GitHub repository.

            Rules:
            - Only use labels that are present in AVAILABLE_LABELS.
            - You may choose multiple labels.
            - Output ONLY valid JSON (no markdown, no extra text).

            AVAILABLE_LABELS (comma-separated):
            "${AVAILABLE_LABELS}"

            ISSUE_TITLE:
            "${ISSUE_TITLE}"

            ISSUE_BODY:
            "${ISSUE_BODY}"

            Output schema:
            {"labels_to_set":["label1","label2"],"explanation":"short reason"}

            If you cannot confidently classify:
            {"labels_to_set":[],"explanation":"Not enough info to classify with existing labels"}

      - name: Parse Gemini output
        id: parse
        shell: bash
        env:
          OUT: ${{ steps.gemini.outputs.stdout }}
        run: |
          python - <<'PY'
          import json, os, sys
          out = os.environ.get("OUT","").strip()
          if not out:
            print("No output from Gemini.", file=sys.stderr)
            print("labels_to_set=", file=open(os.environ["GITHUB_OUTPUT"],"a"))
            print("explanation=", file=open(os.environ["GITHUB_OUTPUT"],"a"))
            sys.exit(0)
          try:
            data = json.loads(out)
          except Exception as e:
            print("Gemini output is not valid JSON:", file=sys.stderr)
            print(out, file=sys.stderr)
            raise
          labels = data.get("labels_to_set") or []
          expl = data.get("explanation") or ""
          # normalize to CSV
          csv = ",".join([str(x).strip() for x in labels if str(x).strip()])
          with open(os.environ["GITHUB_OUTPUT"],"a") as f:
            f.write(f"labels_to_set={csv}\n")
            f.write(f"explanation={expl}\n")
          PY

      - name: Apply labels
        if: steps.parse.outputs.labels_to_set != ''
        uses: actions/github-script@v8
        env:
          CSV: ${{ steps.parse.outputs.labels_to_set }}
        with:
          script: |
            const labels = (process.env.CSV || "")
              .split(",")
              .map(s => s.trim())
              .filter(Boolean);

            if (!labels.length) return;

            await github.rest.issues.setLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels,
            });

      - name: Comment on issue
        uses: actions/github-script@v8
        env:
          EXPL: ${{ steps.parse.outputs.explanation }}
          CSV: ${{ steps.parse.outputs.labels_to_set }}
        with:
          script: |
            const explanation = (process.env.EXPL || "").trim();
            const csv = (process.env.CSV || "").trim();
            const labelsText = csv ? csv.split(",").map(s => `\`${s.trim()}\``).join(", ") : "_(none)_";
            const body =
              `ðŸ¤– **Gemini Triage**\n\n` +
              `**Labels:** ${labelsText}\n\n` +
              (explanation ? `**Why:** ${explanation}` : `**Why:** _(no explanation provided)_`);

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body,
            });
