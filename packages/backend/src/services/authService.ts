import bcrypt from 'bcryptjs'
import { prisma } from '../lib/prisma.js'
import { redis } from '../lib/redis.js'
import type { Professional } from '@prisma/client'

export interface LoginInput {
  email: string
  password: string
  barbershopId: string
}

export interface AuthResponse {
  accessToken: string
  refreshToken: string
  professional: Pick<Professional, 'id' | 'name' | 'email' | 'role'>
}

export class AuthService {
  async findProfessionalByEmail(email: string, barbershopId: string): Promise<Professional | null> {
    return prisma.professional.findFirst({
      where: {
        email,
        barbershopId,
      },
    })
  }

  async login(input: LoginInput): Promise<AuthResponse> {
    // Find professional by email and barbershop
    const professional = await this.findProfessionalByEmail(input.email, input.barbershopId)

    if (!professional) {
      throw new Error('Invalid credentials')
    }

    // Verify password
    const passwordValid = await bcrypt.compare(input.password, professional.passwordHash)
    if (!passwordValid) {
      throw new Error('Invalid credentials')
    }

    // Generate tokens would be done in controller using Fastify JWT
    return {
      accessToken: '', // Will be generated by controller
      refreshToken: '', // Will be stored in Redis by controller
      professional: { id: professional.id, name: professional.name, email: professional.email, role: professional.role },
    }
  }

  async saveRefreshToken(professionalId: string, barbershopId: string, refreshToken: string): Promise<void> {
    const key = `barbershop:refresh:${barbershopId}:${professionalId}`
    // 7 days TTL
    await redis.setex(key, 604800, refreshToken)
  }

  async getRefreshToken(professionalId: string, barbershopId: string): Promise<string | null> {
    const key = `barbershop:refresh:${barbershopId}:${professionalId}`
    return redis.get(key)
  }

  async deleteRefreshToken(professionalId: string, barbershopId: string): Promise<void> {
    const key = `barbershop:refresh:${barbershopId}:${professionalId}`
    await redis.del(key)
  }

  async requestOTP(email: string, barbershopId: string): Promise<void> {
    // Generate 6-digit OTP
    const otp = Math.floor(100000 + Math.random() * 900000).toString()

    // Store in Redis with 5 minute TTL
    const key = `barbershop:otp:${barbershopId}:${email}`
    await redis.setex(key, 300, otp)

    // TODO: Send email with OTP (implement email service)
    console.log(`OTP for ${email}: ${otp}`)
  }

  async verifyOTP(email: string, barbershopId: string, otp: string): Promise<boolean> {
    const key = `barbershop:otp:${barbershopId}:${email}`
    const storedOTP = await redis.get(key)
    const storedOTPString = storedOTP === null ? null : String(storedOTP)

    if (!storedOTPString || storedOTPString !== otp) {
      return false
    }

    // Delete OTP after verification
    await redis.del(key)
    return true
  }
}

export const authService = new AuthService()
